"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiProvider = void 0;
const generative_ai_1 = require("@google/generative-ai");
const base_1 = require("./base");
class GeminiProvider extends base_1.BaseVisionProvider {
    constructor(apiKey, timeout, maxRetries) {
        super(timeout, maxRetries);
        this.id = 'google:gemini-1.5-flash';
        if (!apiKey) {
            throw this.createError('Google Gemini API key is required', 500);
        }
        this.client = new generative_ai_1.GoogleGenerativeAI(apiKey);
    }
    async callProvider(imageUrl, options = {}) {
        this.validateImageUrl(imageUrl);
        const startTime = Date.now();
        try {
            const result = await this.withRetry(async () => {
                // Fetch the image data
                const imageResponse = await fetch(imageUrl);
                if (!imageResponse.ok) {
                    throw this.createError(`Failed to fetch image: ${imageResponse.statusText}`, 400);
                }
                const imageBuffer = await imageResponse.arrayBuffer();
                const mimeType = imageResponse.headers.get('content-type') || 'image/jpeg';
                // Validate image type
                if (!mimeType.startsWith('image/')) {
                    throw this.createError('URL does not point to a valid image', 400);
                }
                const model = this.client.getGenerativeModel({ model: 'gemini-1.5-flash' });
                const prompt = options.systemPrompt || 'Describe this image in detail for a machine learning dataset. Focus on the main subject, setting, colors, and any notable features. Keep the description concise but informative.';
                const imagePart = {
                    inlineData: {
                        data: Buffer.from(imageBuffer).toString('base64'),
                        mimeType
                    }
                };
                const response = await this.withTimeout(model.generateContent([prompt, imagePart]));
                const caption = response.response.text();
                if (!caption) {
                    throw this.createError('No caption generated by Gemini', 500);
                }
                return {
                    modelId: this.id,
                    caption: caption.trim(),
                    latency: Date.now() - startTime,
                    // Gemini doesn't provide token usage in the same way
                    tokensUsed: undefined
                };
            });
            return result;
        }
        catch (error) {
            if (error instanceof Error) {
                // Handle specific Gemini errors
                if (error.message.includes('QUOTA_EXCEEDED')) {
                    throw this.createError('Gemini quota exceeded', 429);
                }
                if (error.message.includes('API_KEY_INVALID')) {
                    throw this.createError('Invalid Gemini API key', 401);
                }
                if (error.message.includes('SAFETY')) {
                    throw this.createError('Content blocked by safety filters', 400);
                }
                if (error.message.includes('RECITATION')) {
                    throw this.createError('Content blocked due to recitation', 400);
                }
            }
            // Re-throw ProxyError as-is
            if (error instanceof Error && 'statusCode' in error) {
                throw error;
            }
            throw this.createError(`Gemini API error: ${error instanceof Error ? error.message : 'Unknown error'}`, 500);
        }
    }
}
exports.GeminiProvider = GeminiProvider;
//# sourceMappingURL=gemini.js.map