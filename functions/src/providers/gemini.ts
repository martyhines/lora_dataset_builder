import { GoogleGenerativeAI } from '@google/generative-ai';
import { BaseVisionProvider } from './base';
import { CaptionResult } from '../types';

export class GeminiProvider extends BaseVisionProvider {
  id = 'google:gemini-2.0-flash';
  private client: GoogleGenerativeAI;

  constructor(apiKey: string, timeout?: number, maxRetries?: number) {
    super(timeout, maxRetries);
    
    if (!apiKey) {
      throw this.createError('Google Gemini API key is required', 500);
    }

    this.client = new GoogleGenerativeAI(apiKey);
  }

  async callProvider(imageUrl: string, options: any = {}): Promise<CaptionResult> {
    this.validateImageUrl(imageUrl);
    
    const startTime = Date.now();

    try {
      const result = await this.withRetry(async () => {
        // Fetch the image data
        const imageResponse = await fetch(imageUrl);
        if (!imageResponse.ok) {
          throw this.createError(`Failed to fetch image: ${imageResponse.statusText}`, 400);
        }

        const imageBuffer = await imageResponse.arrayBuffer();
        const mimeType = imageResponse.headers.get('content-type') || 'image/jpeg';

        // Validate image type
        if (!mimeType.startsWith('image/')) {
          throw this.createError('URL does not point to a valid image', 400);
        }

        const model = this.client.getGenerativeModel({ model: 'gemini-2.0-flash' });

        const prompt = options.systemPrompt || 'Describe this image in detail for a machine learning dataset. Focus on the main subject, setting, colors, and any notable features. Keep the description concise but informative.';

        const imagePart = {
          inlineData: {
            data: Buffer.from(imageBuffer).toString('base64'),
            mimeType
          }
        };

        const response = await this.withTimeout(
          model.generateContent([prompt, imagePart])
        );

        const caption = response.response.text();
        if (!caption) {
          throw this.createError('No caption generated by Gemini', 500);
        }

        return {
          modelId: this.id,
          caption: caption.trim(),
          latency: Date.now() - startTime,
          // Gemini doesn't provide token usage in the same way
          tokensUsed: undefined
        };
      });

      return result;
    } catch (error) {
      if (error instanceof Error) {
        // Handle specific Gemini errors
        if (error.message.includes('QUOTA_EXCEEDED')) {
          throw this.createError('Gemini quota exceeded', 429);
        }
        if (error.message.includes('API_KEY_INVALID')) {
          throw this.createError('Invalid Gemini API key', 401);
        }
        if (error.message.includes('SAFETY')) {
          throw this.createError('Content blocked by safety filters', 400);
        }
        if (error.message.includes('RECITATION')) {
          throw this.createError('Content blocked due to recitation', 400);
        }
      }

      // Re-throw ProxyError as-is
      if (error instanceof Error && 'statusCode' in error) {
        throw error;
      }

      throw this.createError(`Gemini API error: ${error instanceof Error ? error.message : 'Unknown error'}`, 500);
    }
  }
}